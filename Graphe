using System;
using System.Collections.Generic;
using System.Linq;

namespace LivInParisApp
{
    public class Graphe<T>
    {
        public List<Noeud<T>> Noeuds { get; private set; }
        public bool EstOriente { get; private set; }

        public Graphe(bool estOriente = true)
        {
            Noeuds = new List<Noeud<T>>();
            EstOriente = estOriente;
        }

        public void AjouterNoeud(Noeud<T> noeud)
        {
            if (!Noeuds.Contains(noeud))
            {
                Noeuds.Add(noeud);
            }
        }

        public void AjouterLien(Noeud<T> source, Noeud<T> destination, double poids)
        {
            // Vérifier que les deux noeuds existent dans le graphe
            if (!Noeuds.Contains(source))
                Noeuds.Add(source);

            if (!Noeuds.Contains(destination))
                Noeuds.Add(destination);

            // Ajouter le lien
            source.AjouterVoisin(destination, poids);

            // Si le graphe n'est pas orienté, ajouter également le lien inverse
            if (!EstOriente)
            {
                destination.AjouterVoisin(source, poids);
            }
        }

        // Charger les données du métro à partir d'un fichier
        public void ChargerDonneesMetro(string cheminFichier)
        {
            try
            {
                string[] lignes = System.IO.File.ReadAllLines(cheminFichier);
                bool premiereLigne = true;

                // Dictionnaire pour conserver les stations déjà créées
                Dictionary<string, Noeud<T>> stationsExistantes = new Dictionary<string, Noeud<T>>();

                foreach (string ligne in lignes)
                {
                    // Ignorer l'en-tête
                    if (premiereLigne)
                    {
                        premiereLigne = false;
                        continue;
                    }

                    string[] donnees = ligne.Split(';');

                    // Structure attendue du fichier CSV : ID_Station;Nom;Ligne;Latitude;Longitude;ID_Suivante;Temps_Vers_Suivante;ID_Precedente;Temps_Vers_Precedente
                    if (donnees.Length >= 9)
                    {
                        string idStation = donnees[0];
                        string nomStation = donnees[1];
                        int ligneMetro = int.Parse(donnees[2]);
                        double latitude = double.Parse(donnees[3], System.Globalization.CultureInfo.InvariantCulture);
                        double longitude = double.Parse(donnees[4], System.Globalization.CultureInfo.InvariantCulture);

                        string idSuivante = donnees[5];
                        double tempsSuivante = string.IsNullOrEmpty(donnees[6]) ? 0 : double.Parse(donnees[6], System.Globalization.CultureInfo.InvariantCulture);

                        string idPrecedente = donnees[7];
                        double tempsPrecedente = string.IsNullOrEmpty(donnees[8]) ? 0 : double.Parse(donnees[8], System.Globalization.CultureInfo.InvariantCulture);

                        // Créer ou récupérer le noeud actuel
                        string cleStation = $"{nomStation}_{ligneMetro}";
                        if (!stationsExistantes.ContainsKey(cleStation))
                        {
                            Noeud<T> noeudActuel = new Noeud<T>(default(T), nomStation, latitude, longitude, ligneMetro);
                            stationsExistantes.Add(cleStation, noeudActuel);
                            AjouterNoeud(noeudActuel);
                        }

                        // Traiter les liens vers la station suivante
                        if (!string.IsNullOrEmpty(idSuivante) && tempsSuivante > 0)
                        {
                            // Chercher la station suivante dans le fichier
                            foreach (string autreLigne in lignes)
                            {
                                if (autreLigne.StartsWith(idSuivante + ";"))
                                {
                                    string[] donneesAutre = autreLigne.Split(';');
                                    string nomAutre = donneesAutre[1];
                                    int ligneAutre = int.Parse(donneesAutre[2]);
                                    double latAutre = double.Parse(donneesAutre[3], System.Globalization.CultureInfo.InvariantCulture);
                                    double longAutre = double.Parse(donneesAutre[4], System.Globalization.CultureInfo.InvariantCulture);

                                    string cleAutre = $"{nomAutre}_{ligneAutre}";
                                    if (!stationsExistantes.ContainsKey(cleAutre))
                                    {
                                        Noeud<T> noeudAutre = new Noeud<T>(default(T), nomAutre, latAutre, longAutre, ligneAutre);
                                        stationsExistantes.Add(cleAutre, noeudAutre);
                                        AjouterNoeud(noeudAutre);
                                    }

                                    AjouterLien(stationsExistantes[cleStation], stationsExistantes[cleAutre], tempsSuivante);
                                    break;
                                }
                            }
                        }

                        // Traiter les liens vers la station précédente
                        if (!string.IsNullOrEmpty(idPrecedente) && tempsPrecedente > 0)
                        {
                            // Chercher la station précédente dans le fichier
                            foreach (string autreLigne in lignes)
                            {
                                if (autreLigne.StartsWith(idPrecedente + ";"))
                                {
                                    string[] donneesAutre = autreLigne.Split(';');
                                    string nomAutre = donneesAutre[1];
                                    int ligneAutre = int.Parse(donneesAutre[2]);
                                    double latAutre = double.Parse(donneesAutre[3], System.Globalization.CultureInfo.InvariantCulture);
                                    double longAutre = double.Parse(donneesAutre[4], System.Globalization.CultureInfo.InvariantCulture);

                                    string cleAutre = $"{nomAutre}_{ligneAutre}";
                                    if (!stationsExistantes.ContainsKey(cleAutre))
                                    {
                                        Noeud<T> noeudAutre = new Noeud<T>(default(T), nomAutre, latAutre, longAutre, ligneAutre);
                                        stationsExistantes.Add(cleAutre, noeudAutre);
                                        AjouterNoeud(noeudAutre);
                                    }

                                    AjouterLien(stationsExistantes[cleStation], stationsExistantes[cleAutre], tempsPrecedente);
                                    break;
                                }
                            }
                        }
                    }
                }

                // Ajouter les correspondances entre stations
                ChargerCorrespondances(cheminFichier);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors du chargement des données métro: {ex.Message}");
            }
        }

        private void ChargerCorrespondances(string cheminFichier)
        {
            try
            {
                string[] lignes = System.IO.File.ReadAllLines(cheminFichier);
                bool premiereLigne = true;

                // Correspondances entre stations de même nom mais de lignes différentes
                Dictionary<string, List<Noeud<T>>> stationsParNom = new Dictionary<string, List<Noeud<T>>>();

                // Regrouper les stations par nom
                foreach (Noeud<T> noeud in Noeuds)
                {
                    if (!stationsParNom.ContainsKey(noeud.Nom))
                    {
                        stationsParNom[noeud.Nom] = new List<Noeud<T>>();
                    }
                    stationsParNom[noeud.Nom].Add(noeud);
                }

                // Ajouter les correspondances entre lignes
                foreach (var nomStation in stationsParNom.Keys)
                {
                    if (stationsParNom[nomStation].Count > 1)
                    {
                        // Stations de correspondance
                        for (int i = 0; i < stationsParNom[nomStation].Count; i++)
                        {
                            for (int j = i + 1; j < stationsParNom[nomStation].Count; j++)
                            {
                                Noeud<T> station1 = stationsParNom[nomStation][i];
                                Noeud<T> station2 = stationsParNom[nomStation][j];

                                // Temps de correspondance (par défaut 3 minutes)
                                double tempsCorrespondance = 3.0;

                                // Ajouter les liens bidirectionnels pour les correspondances
                                AjouterLien(station1, station2, tempsCorrespondance);
                                AjouterLien(station2, station1, tempsCorrespondance);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors du chargement des correspondances: {ex.Message}");
            }
        }

        // Recherche du plus court chemin avec l'algorithme de Dijkstra
        public List<Noeud<T>> Dijkstra(Noeud<T> source, Noeud<T> destination)
        {
            if (!Noeuds.Contains(source) || !Noeuds.Contains(destination))
                return new List<Noeud<T>>();

            Dictionary<Noeud<T>, double> distances = new Dictionary<Noeud<T>, double>();
            Dictionary<Noeud<T>, Noeud<T>> predecesseurs = new Dictionary<Noeud<T>, Noeud<T>>();
            List<Noeud<T>> nonVisites = new List<Noeud<T>>();

            foreach (Noeud<T> noeud in Noeuds)
            {
                distances[noeud] = noeud.Equals(source) ? 0 : double.MaxValue;
                nonVisites.Add(noeud);
            }

            while (nonVisites.Count > 0)
            {
                Noeud<T> noeudActuel = null;
                double minDistance = double.MaxValue;

                foreach (Noeud<T> noeud in nonVisites)
                {
                    if (distances[noeud] < minDistance)
                    {
                        minDistance = distances[noeud];
                        noeudActuel = noeud;
                    }
                }

                if (noeudActuel == null || noeudActuel.Equals(destination))
                    break;

                nonVisites.Remove(noeudActuel);

                foreach (var paire in noeudActuel.Voisins)
                {
                    Noeud<T> voisin = paire.Key;
                    double poids = paire.Value;
                    double distance = distances[noeudActuel] + poids;

                    if (distance < distances[voisin])
                    {
                        distances[voisin] = distance;
                        predecesseurs[voisin] = noeudActuel;
                    }
                }
            }

            List<Noeud<T>> chemin = new List<Noeud<T>>();
            Noeud<T> noeudCourant = destination;

            if (predecesseurs.ContainsKey(destination))
            {
                while (noeudCourant != null)
                {
                    chemin.Insert(0, noeudCourant);
                    if (noeudCourant.Equals(source))
                        break;
                    noeudCourant = predecesseurs.ContainsKey(noeudCourant) ? predecesseurs[noeudCourant] : null;
                }
            }

            return chemin;
        }

        public List<Noeud<T>> ParcoursLargeur(T dataInitial)
        {
            var depart = Noeuds.FirstOrDefault(n => n.Data.Equals(dataInitial));
            if (depart == null)
                return new List<Noeud<T>>();

            var parcours = new List<Noeud<T>>();
            var fifo = new Queue<Noeud<T>>();
            var visites = new HashSet<Noeud<T>>();

            fifo.Enqueue(depart);
            visites.Add(depart);
            while (fifo.Count > 0)
            {
                var courant = fifo.Dequeue();
                parcours.Add(courant);
                foreach (var voisin in courant.Voisins.Keys)
                {
                    if (!visites.Contains(voisin))
                    {
                        fifo.Enqueue(voisin);
                        visites.Add(voisin);
                    }
                }
            }
            return parcours;
        }


        // Recherche du plus court chemin avec l'algorithme de Bellman-Ford
        public List<Noeud<T>> BellmanFord(Noeud<T> source, Noeud<T> destination)
        {
            if (!Noeuds.Contains(source) || !Noeuds.Contains(destination))
                return new List<Noeud<T>>();

            Dictionary<Noeud<T>, double> distances = new Dictionary<Noeud<T>, double>();
            Dictionary<Noeud<T>, Noeud<T>> predecesseurs = new Dictionary<Noeud<T>, Noeud<T>>();

            foreach (Noeud<T> noeud in Noeuds)
            {
                distances[noeud] = noeud.Equals(source) ? 0 : double.MaxValue;
            }

            for (int i = 0; i < Noeuds.Count - 1; i++)
            {
                foreach (Noeud<T> noeud in Noeuds)
                {
                    foreach (var paire in noeud.Voisins)
                    {
                        Noeud<T> voisin = paire.Key;
                        double poids = paire.Value;

                        if (distances[noeud] != double.MaxValue && distances[noeud] + poids < distances[voisin])
                        {
                            distances[voisin] = distances[noeud] + poids;
                            predecesseurs[voisin] = noeud;
                        }
                    }
                }
            }

            foreach (Noeud<T> noeud in Noeuds)
            {
                foreach (var paire in noeud.Voisins)
                {
                    Noeud<T> voisin = paire.Key;
                    double poids = paire.Value;

                    if (distances[noeud] != double.MaxValue && distances[noeud] + poids < distances[voisin])
                    {
                        Console.WriteLine("Attention: Le graphe contient un cycle de poids négatif.");
                        return new List<Noeud<T>>();
                    }
                }
            }

            List<Noeud<T>> chemin = new List<Noeud<T>>();
            Noeud<T> noeudCourant = destination;

            if (predecesseurs.ContainsKey(destination))
            {
                while (noeudCourant != null)
                {
                    chemin.Insert(0, noeudCourant);
                    if (noeudCourant.Equals(source))
                        break;
                    noeudCourant = predecesseurs.ContainsKey(noeudCourant) ? predecesseurs[noeudCourant] : null;
                }
            }

            return chemin;
        }

        // Recherche du plus court chemin avec l'algorithme de Floyd-Warshall
        public List<Noeud<T>> FloydWarshall(Noeud<T> source, Noeud<T> destination)
        {
            if (!Noeuds.Contains(source) || !Noeuds.Contains(destination))
                return new List<Noeud<T>>();

            int n = Noeuds.Count;
            double[,] dist = new double[n, n];
            int[,] next = new int[n, n];

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    dist[i, j] = double.MaxValue;
                    next[i, j] = -1;
                }
            }

            for (int i = 0; i < n; i++)
            {
                dist[i, i] = 0;
                foreach (var paire in Noeuds[i].Voisins)
                {
                    int j = Noeuds.IndexOf(paire.Key);
                    if (j != -1)
                    {
                        dist[i, j] = paire.Value;
                        next[i, j] = j;
                    }
                }
            }

            for (int k = 0; k < n; k++)
            {
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (dist[i, k] != double.MaxValue && dist[k, j] != double.MaxValue)
                        {
                            if (dist[i, j] > dist[i, k] + dist[k, j])
                            {
                                dist[i, j] = dist[i, k] + dist[k, j];
                                next[i, j] = next[i, k];
                            }
                        }
                    }
                }
            }

            List<Noeud<T>> chemin = new List<Noeud<T>>();
            int sourceIndex = Noeuds.IndexOf(source);
            int destIndex = Noeuds.IndexOf(destination);

            if (next[sourceIndex, destIndex] == -1)
                return chemin;

            chemin.Add(source);
            while (sourceIndex != destIndex)
            {
                sourceIndex = next[sourceIndex, destIndex];
                if (sourceIndex == -1)
                    return new List<Noeud<T>>();
                chemin.Add(Noeuds[sourceIndex]);
            }

            return chemin;
        }

        // Comparer les résultats des 3 algorithmes
        public void ComparerAlgorithmes(Noeud<T> source, Noeud<T> destination)
        {
            Console.WriteLine($"Comparaison des algorithmes pour le trajet de {source} à {destination}");

            var startDijkstra = DateTime.Now;
            var cheminDijkstra = Dijkstra(source, destination);
            var tempsDijkstra = (DateTime.Now - startDijkstra).TotalMilliseconds;

            var startBellman = DateTime.Now;
            var cheminBellman = BellmanFord(source, destination);
            var tempsBellman = (DateTime.Now - startBellman).TotalMilliseconds;

            var startFloyd = DateTime.Now;
            var cheminFloyd = FloydWarshall(source, destination);
            var tempsFloyd = (DateTime.Now - startFloyd).TotalMilliseconds;

            Console.WriteLine("\nRésultats Dijkstra:");
            AfficherChemin(cheminDijkstra);
            Console.WriteLine($"Temps d'exécution: {tempsDijkstra} ms");

            Console.WriteLine("\nRésultats Bellman-Ford:");
            AfficherChemin(cheminBellman);
            Console.WriteLine($"Temps d'exécution: {tempsBellman} ms");

            Console.WriteLine("\nRésultats Floyd-Warshall:");
            AfficherChemin(cheminFloyd);
            Console.WriteLine($"Temps d'exécution: {tempsFloyd} ms");

            Console.WriteLine("\nComparaison des performances:");
            Console.WriteLine($"Dijkstra: {tempsDijkstra} ms - Complexité O(E + V log V)");
            Console.WriteLine($"Bellman-Ford: {tempsBellman} ms - Complexité O(V*E)");
            Console.WriteLine($"Floyd-Warshall: {tempsFloyd} ms - Complexité O(V^3)");

            Console.WriteLine("\nAnalyse:");
            Console.WriteLine("- Dijkstra est généralement le plus rapide pour les graphes sans poids négatifs.");
            Console.WriteLine("- Bellman-Ford peut gérer les poids négatifs mais est plus lent que Dijkstra.");
            Console.WriteLine("- Floyd-Warshall calcule tous les chemins les plus courts entre toutes les paires de sommets, ce qui le rend utile pour des requêtes multiples mais plus lent pour une seule requête.");
        }

        private void AfficherChemin(List<Noeud<T>> chemin)
        {
            if (chemin.Count == 0)
            {
                Console.WriteLine("Aucun chemin trouvé.");
                return;
            }

            double tempsTotal = 0;
            Console.WriteLine($"Chemin trouvé ({chemin.Count} stations):");

            for (int i = 0; i < chemin.Count; i++)
            {
                Console.WriteLine($"{i + 1}. {chemin[i]}");
                if (i < chemin.Count - 1)
                {
                    double tempsTroncon = chemin[i].Voisins[chemin[i + 1]];
                    tempsTotal += tempsTroncon;
                    if (chemin[i].LigneMetro != chemin[i + 1].LigneMetro)
                    {
                        Console.WriteLine($"   Correspondance: Ligne {chemin[i].LigneMetro} → Ligne {chemin[i + 1].LigneMetro} ({tempsTroncon} min)");
                    }
                    else
                    {
                        Console.WriteLine($"   → ({tempsTroncon} min)");
                    }
                }
            }

            Console.WriteLine($"Temps total estimé: {tempsTotal} minutes");
        }
        public void ChargerDonneesCSV(string cheminFichier)
        {
            try
            {
                string[] lignes = System.IO.File.ReadAllLines(cheminFichier);
                bool premiereLigne = true;

                // Dictionnaire pour conserver les stations déjà créées
                Dictionary<int, Noeud<T>> stationsExistantes = new Dictionary<int, Noeud<T>>();

                foreach (string ligne in lignes)
                {
                    // Ignorer l'en-tête
                    if (premiereLigne)
                    {
                        premiereLigne = false;
                        continue;
                    }

                    string[] donnees = ligne.Split(';');

                    // Structure attendue du fichier CSV : Station Id;Station;Précédent;Suivant;Temps entre 2 stations;Temps de Changement
                    if (donnees.Length >= 6)
                    {
                        int idStation = int.Parse(donnees[0]);
                        string nomStation = donnees[1];
                        int? idPrecedent = string.IsNullOrEmpty(donnees[2]) ? (int?)null : int.Parse(donnees[2]);
                        int? idSuivant = string.IsNullOrEmpty(donnees[3]) ? (int?)null : int.Parse(donnees[3]);
                        double tempsEntreStations = double.Parse(donnees[4], System.Globalization.CultureInfo.InvariantCulture);
                        double tempsChangement = double.Parse(donnees[5], System.Globalization.CultureInfo.InvariantCulture);

                        // Créer ou récupérer le noeud actuel
                        if (!stationsExistantes.ContainsKey(idStation))
                        {
                            Noeud<T> noeudActuel = new Noeud<T>(default(T), nomStation, 0, 0, idStation);
                            stationsExistantes.Add(idStation, noeudActuel);
                            AjouterNoeud(noeudActuel);
                        }

                        // Traiter les liens vers la station suivante
                        if (idSuivant.HasValue && tempsEntreStations > 0)
                        {
                            if (!stationsExistantes.ContainsKey(idSuivant.Value))
                            {
                                Noeud<T> noeudSuivant = new Noeud<T>(default(T), donnees[3], 0, 0, idSuivant.Value);
                                stationsExistantes.Add(idSuivant.Value, noeudSuivant);
                                AjouterNoeud(noeudSuivant);
                            }

                            AjouterLien(stationsExistantes[idStation], stationsExistantes[idSuivant.Value], tempsEntreStations);
                        }

                        // Traiter les liens vers la station précédente
                        if (idPrecedent.HasValue && tempsEntreStations > 0)
                        {
                            if (!stationsExistantes.ContainsKey(idPrecedent.Value))
                            {
                                Noeud<T> noeudPrecedent = new Noeud<T>(default(T), donnees[2], 0, 0, idPrecedent.Value);
                                stationsExistantes.Add(idPrecedent.Value, noeudPrecedent);
                                AjouterNoeud(noeudPrecedent);
                            }

                            AjouterLien(stationsExistantes[idStation], stationsExistantes[idPrecedent.Value], tempsEntreStations);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors du chargement des données CSV: {ex.Message}");
            }
        }
    }
}
